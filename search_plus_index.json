{"./":{"url":"./","title":"0、SQLRestful概要说明","keywords":"","body":"SQLRestful概要说明 云原生开发工具 SQLRestful是一个开箱即用的云原生微服务开发工具，通过SQLRestful您可以快速变现数据库设计为Restful微服务接口。它采用Go语言实现，开发者通过HCL配置语言实现微服务接口开发，其配置语法直遵循Restful规范及面向对象微服务的设计思路，其目的是为了尽量缩短服务组件从设计到部署的实现周期。 基于SQLRestful您可以借助传统的SQL与JavaScript技术来快速响应需求，解决云原生开发环境下的人员技能无法跟上发展的窘况。 什么是云原生应用 2015年谷歌成立了原生云计算基金会（CNCF），目前基金会成员包含Box、华为、思科、Docker、eBay、IBM、英特尔、红帽、Twitter、VMware、三星等70多家成员。 CNCF认为CloudNative（云原生）系统需包含的属性： 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。 自动化管理：统一调度和管理中心，从根本上提高系统和资源利用率，同时降低运维成本。 面向微服务：通过松耦合方式，提升应用程序的整体敏捷性和可维护性。 而云原生应用开发方式主要解决传统开发面临的问题： 设计、开发、测试、部署、运维无法一体化，迭代困难； 无法做到随需扩展部署导致并发能力固化，资源利用率低； 为我们提供捐助 如果您觉得SQLRestful云原生开发工具能给您带来收益： 设计思路上的借鉴； 节省了您的项目成本； 让您的SQL技能继续发光发热； 给您带来了更多闲暇时间； (留给您来补充！) 在您心情愉悦之际，扫下方的二维码捐助我们： 微信扫码 支付宝扫码 感谢您的打赏支持！ 开源仓库地址 https://github.com/neeker/sqlrestful 2019-2010 © 版权所有 "},"origin.html":{"url":"origin.html","title":"1、SQLRestful设计初衷","keywords":"","body":"SQLRestful设计初衷 一直在使用Java+SpringBoot作为微服务生产力工具，通常来讲实现一个Restful微服务接口需要做以下相关工作： ORM映射实现：通常使用MyBatis，需要写Pojo类、Mapper类和SQLProvider类。 服务层实现：需要一个对象管理接口类与一个对象管理实现类。 控制层实现：一个RestConfoller类并注解Rest方法再调用服务层实现。 Devops配置：Dockerfile、k8s部署描述文件等等。 这样一个Restful接口实现下来至少需要5个以上的类，大部分工作是在做转换、校验等语言相关的工作。 我们可以想想从SQL到Restful经历了多少层的实现，而大部分工作是毫无意义的规则代码。。。 您可能会建议我使用spring-cloud开发框架，但一样也少不上述过程。 因此一直以来，我一直想要有一个工具可以直接把SQL转成Restful微服务接口，同时它必须是云原生的开发方式： 1、配置化实现：通过简单的配置边可以很方便的实现SQL转Restful接口； 2、执行效率高：不能因为配置和转换减低运行效率； 3、可容器化部署：能方便打包成Docker镜像并运行； 4、多数据库支持：包括oracle、db2、mysql、postgres、hadoop等。 通过此工具可以快速对外提供Restful规范的数据微服务接口，满足碎片化的数据服务需求应用场景的快速响应。 说干就干，于是我找到了sqler，但是sqler仅支持REST而不支持完整的Restful规范。 因此我在其基础之上实现了一个完整的SQL转Restful接口的服务工具，兼容sqler配置语法的同时进行了Restful配置扩展实现。 感谢开源！ 2019-2010 © 版权所有 "},"start.html":{"url":"start.html","title":"2、SQLRestful入门示例","keywords":"","body":"SQLRestful开发入门示例 开发环境要求 docker notepad或vscode或editplus curl（可选） Linux或Windows 准备SQLRestful脚本 使用如下命令创建一个demo.hcl文件： cat>demo.hcl 👉这里可以直接下载demo.hcl文件👈。 运行SQLRestful开发的微服务 命令行执行以下docker命令运行示例脚本开发的微服务接口： docker run -ti --rm -p 80:80 \\ -v /path/of/your_demo.hcl:/test/demo.hcl:ro \\ snz1/sqlrestful \\ -driver \"sqlite3\" \\ -dsn \"/test/db.sqlite?create=true\" \\ --swagger \\ -debug 3 \\ -config /test/demo.hcl \\ -p 80:80前面那个80表示宿主机转发的端口 /path/of/your_demo.hcl为你创建的SQLRestful脚本文件 测试微服务接口 如果你使用远程主机运行SQLRestufl服务请把下面命令中的127.0.0.1替换成远程主机地址。 新增数据测试 命令行执行： curl -X POST \"http://127.0.0.1/test?name=hello&hello=world\" 命令行返回： {\"code\":0,\"data\":{\"hello\":\"world\",\"name\":\"hello\"},\"message\":\"操作成功！\"} 查询数据测试 命令行执行： curl -X GET \"http://127.0.0.1/test?limit=15 命令行返回： {\"code\":0,\"data\":{\"data\":[{\"hello\":\"world\",\"name\":\"hello\"}],\"offset\":\"0\",\"total\":1},\"message\":\"操作成功！\"} 通过swagger测试 新开标签并打开网址http://127.0.0.1/swagger-ui.html，如下图所示： SQlRestful提供了一个SwaggerUI界面用于测试实现的微服务接口，其默认是禁用的。如果需要启用SwaggerUI界面请在启动命令中加上-swagger开关。 进一步了解 SQLRestful除了可以使用sql实现简单的微服务接口外，还可以配合js脚本实现复杂功能的，包括： 内置多种数据库支持（参见【数据库支持列表】） 可通过js脚本实现可变条件的SQL查询； 可通过js配置实现对请求参数的校验； 可通过js实现SQL查询结果转换； js脚本可请求其他接口并支持jwt规范； 为接口提供配置方式的Redis缓存实现； 提供基于用户统一安全认证服务规范的权限验证配置 使用建议 ☞ SQLRestful云原生开发工具是为了节省数据中台服务接口的开发成本！ ☞ SQLRestful不能适用于复杂业务逻辑的应用场景，总之合适的才是最好的！ 2019-2010 © 版权所有 "},"hcl.html":{"url":"hcl.html","title":"3、HCL配置语言入门","keywords":"","body":"HCL配置语言入门 HCL配置语言请参见HCL官网。 它是大名鼎鼎的云基础架构自动化工具hashicorp实现的配置语言， 它吸收了JSON与YAML及一些脚本语言的特性，自身兼容JSON语法： 单行注释以#或开头// 多行注释包含在/和中/。不允许嵌套块注释。多行注释（也称为块注释）在第一个*/找到时终止。 属性值设置用key = value（空格忽略）表示。value可以是字符串，数字，布尔值，对象或列表。 字符串必须用双引号，可以包含任何UTF-8字符。例：\"Hello, World\" 多行字符串从一行 数字默认为10禁止，如果前缀为0x的数字，则将其视为十六进制。如果它以0为前缀，则将其视为八进制。数字可以是科学记数法：“1e10”。 布尔值：true，false 数组可以通过包装来制作[]。示例： [\"foo\", \"bar\", 42]。数组可以包含基础类型、其他数组和对象。作为替代方案，可以使用以下结构使用重复的块创建对象列表： service { key = \"value\" } service { key = \"value\" } 2019-2010 © 版权所有 "},"macros.html":{"url":"macros.html","title":"4、SQLRestful语法结构","keywords":"","body":"SQLRestful的HCL语法结构 SQLRestful采用HCL语言配合SQL、JavaScript脚本来开发微服务接口。 参见上一章HCL配置语言入门了解HCL语言基本概念 SQLRestful设计上遵循Restful规范，采用路径、方法对应对象的不同操作语义，具体结构如下图所示： 2019-2010 © 版权所有 "},"macro.html":{"url":"macro.html","title":"4.1、Restful接口定义语法结构","keywords":"","body":"Restful接口定义语法结构 接口宏定义语法结构 //用于restful接口中的get、post、put、patch、delete等属性定义 api_name { //服务接口的分类标签（用于swagger文档输出，可忽略），可继承自上级定义 tags = [\"标签\"] //摘要描述（用于swagger文档输出，可忽略） desc = \"\" //引入其他宏定义 include = [\"_boot\"] //返回值类型：list（列表，默认）、object（对象）、page（分页） result = \"list\" //校验表达式：JS脚本实现 validators { value = \"express value\" //表达式为真表示校验通过 } //身份验证：返回true表示身份验证通过（可忽略） authorizer = scope = \"employee\" //判定角色列表 roles = [ \"ADMIN\" ] //判定用户列表 users = [ \"neeker\" ] //角色或用户判定策略： // 为allow时表示请求用户必须包含roles中定义的角色、用户必须在users定义的列表中 // 为deny时表示请求用户不能是roles定义的角色、用户不能再users定义的列表中 //条件不满足则返回403应答 policy = \"allow\" } //Redis缓存配置（无redis连接配置时无效） cache { //缓存名称列表(HSET)：使用input作为field主键 put = [\"cache_name\"] //移除缓存(HSET)：删除HSET主键 evit = [\"cache_name\"] } //表示total与exec的脚本类型：sql（默认），js，exec（命令） impl = \"sql\" //SQL执行变量绑定，impl = \"sql\"时生效 bind { sql_param1 = \"$input.id\" //JS脚本 sql_offset = \"$input.offset\" //默认为0 sql_limit = \"$input.limit\" //默认为0 } //提供待执行的脚本（JS） provider = Restful接口语法结构 //接口定义名称，不能包含“\\”、“/”、“:”等特殊字符 name { //接口地址，省略时使用接口定义名称作为接口地址，可使用“:变量”方式定义路径变量 path = \"/path/of/object_items\" //服务接口的分类标签（可忽略） tags = [\"标签\"] //摘要描述（可忽略） desc = \"\" //接口GET请求方法宏定义 get { ... //基本宏定义 } //POST请求方法宏定义 post { ... //基本宏定义 } //PUT请求方法宏定义 put { ... //基本宏定义 } //PATCH请求方法宏定义 patch { ... //基本宏定义 } //DELETE请求方法宏定义 delete { ... //基本宏定义 } //以下配置属性可以与【接口宏定义】一致，用于简化配置只有一种操作的接口定义 ... } 2019-2010 © 版权所有 "},"ret.html":{"url":"ret.html","title":"4.2、Restful接口返回的数据格式","keywords":"","body":"Restful接口返回的数据格式 基本格式 默认情况下接口采用信奉封装的JSON数据格式返回，数据格式如下所示： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 \"data\": { //由exec脚本返回的数据内容 ... } } 返回单数据对象 如果定义的exec脚本由SQL语言实现（默认情况），此时exec执行默认返回的是列表数据，因此如果返回单个数据对象时需要给接口定义加上以下配置属性： result = `object` 分页数据格式 在Restful接口上加了total配置属性，则表示接口为分页接口，数据格式如下所示： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 \"data\": { // 分页数据对象 \"offset\": 0, // 起始索引 \"total\": 0, // 总记录数，由total脚本返回的数值 \"data\": [...] //分页数据列表，由exec脚本返回的列表 } } 原样返回脚本数据 SQLRestful默认返回封装格式的数据格式，如果需要原样返回脚本的数据则需要在接口定义加上以下配置： ret=\"origin\" 不返回任何数据 如果需要接口不返回任何数据时，你可以在接口配置上添加'ret=\"nil\"'，此时接口执行完exec脚本后仅返回封装应答头，如下所示： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 } 2019-2010 © 版权所有 "},"sql.html":{"url":"sql.html","title":"4.3、SQL参数绑定及返回值约定","keywords":"","body":"SQL参数绑定及返回值约定 SQLRestful默认采用SQL来实现Restful接口（total与exec配置定义）。 SQL参数绑定 要求通过bind宏来配置SQL可变参数。其中的属性定义值是JavaScript表达式（也可以是JavaScript闭包函数），参见如下示例配置： bind { name_arg = \"'%' + $input.name + '%'\" end_arg = $input表示接口请求参数对象集，具体参见下一章《SQLRestful的JS脚本能力》 通过上述配置后，可以在exec或total的SQL代码中使用“:”的绑定参数，如下所示： exec = SQL执行分段 在某些情况下一个exec实现可能需要分为多个SQL段执行，在脚本独立的一行中加入“---”分隔符，如下代码所示： exec = 注意： exec与total始终以最后一段SQL的返回作为返回数据。 SQL执行返回值 2019-2010 © 版权所有 "},"js.html":{"url":"js.html","title":"4.5、SQLRestful的JS脚本能力","keywords":"","body":"SQLRestful的JS脚本能力 js脚本用途 在SQLRestful的主要实现由SQL与JavaScript完成，其中JavaScript负责完成下述工作： 与其他微服务接口进行交互； 实现请求身份验证功能； 校验请求参数是否合法； 请求参数到SQL绑定参数转换； SQL返回结果的转换能力； 实现微服务逻辑处理功能； 它支持完整的ECMAScript 5.1规范（由 goja 提供实现支持）。 js脚本的默认变量 在SQLRestful的宏定义中，参数转换（bind宏），身份验证实现（authorizer宏）的JS脚本可以通过$input变量 获取到请求输入参数列表，同时可以通过$input.http_xxxx来获取请求头内容，假设客户端请求发送一个名称为X-Test-MM 的请求，则通过以下表达式拿到请求头内容： $input.http_x_test_mm 所有请求头都会转换成小写加上http_前缀，同时为了遵循JS对象属性命名规则会把“-”替换为“_”。 应答转换（transformer宏）的脚本通过变量$result可以获取到exec宏返回的原始数据，具体见如下示例代码： test { ... transformer = 除此之外，每个JS脚本都可以获取以下参数： 参数名 参数说明 $input.http_method 当前请求方法：GET、POST、PUT、PATCH、DELETE $input.http_scheme 当前请求协议头：http、https $input.http_path 当前请求上下文路径 $input.http_url 当前请求URL地址 $input.http_uri 当前请求URI地址 $input.http_remote_addr 当前请求远程IP地址（或前置代理地址） $input.http_real_ip 当前请求真实IP地址：请求头X-Forwarded-For或X-Real-IP的值 $name 当前微服务实现宏名称 $stage 宏JS所在过程名称：validators、authorizer、transformer、bind、provider、exec、total js脚本内置函数 SQLRestful为JS脚本内置了两个默认的HTTP请求函数和一个控制台日志输出函数： fetch call_api log fetch函数 函数原型 function fetch(URL, { method: \"HTTP METHOD\", //请求方法，如GET、POST、PUT headers: { //请求头 ... }, body: ... //请求体，可以是JSON或字符串。 }) 返回结果 { \"status\": \"应答状态文本\", \"statusCode\": \"HTTP应答码\", \"headers\": \"HTTP应答头\", \"body\": \"应答内容字符串\", } call_api函数 此函数提供后台调用在应用网关中注册的微服务后台接口。 它通过SQLRestful服务配置的 JWT RSA 私钥与 JWT 安全令牌产生 JWT 请求令牌并发起接口请求。 具体JWT令牌请求方式参见《通过网关调用后台服务接口 》中的说明。 函数原型 function call_api(URL, { method: \"HTTP METHOD\", //请求方法，如GET、POST、PUT headers: { //请求头 ... }, body: ... //请求体，可以是JSON或参数内容。 }) 返回结果 正常情况下 call_api 函数直接返回接口的JSON对象，只有在请求出错的情况下返回如下定义： { \"status\": \"应答状态文本\", \"statusCode\": \"HTTP应答码\", \"headers\": \"HTTP应答头\", \"body\": \"应答内容字符串\", } 如果请求的接口应答内容不能转换为JSON对象则返回与fetch函数相同的应答： log函数 函数原型 function log(message, ...) 使用示例 (function(){ log(\"debug:\", \"hello world!\") })() 2019-2010 © 版权所有 "},"professor.html":{"url":"professor.html","title":"5、SQLRestful进阶指南","keywords":"","body":"2019-2010 © 版权所有 "},"sqlx.html":{"url":"sqlx.html","title":"5.1 根据请求参数实现条件分支","keywords":"","body":"根据请求参数实现条件分支 应用场景 有时我们需要根据不同的请求参数来组装SQL的不同条件语句，例如当请求参数传入了年龄参数就需要获取符合年龄条件的 人员，如果请求未传入年龄参数则不需要根据年龄过滤数据，此类场景在一条SQL查询语句中显然无法实现。 此时便需要我们使用执行提供器配置方式（provider配置）来完成复杂的SQL条件分支实现。 provider provider配置采用JavaScript实现，定义了provider意味着微服务接口接下来的执行脚本（包括total与exec)由provider定义的JavaScript返回。 只返回exec执行脚本 provider返回格式可以是简单的字符串，返回的字符串直接用于exec执行，如下所示： provider = 同时返回total与exec provider可以返回用于分页查询接口的total与exec脚本，如下所示： provider = 同时返回脚本类型 provider = total可以不存在于返回结果中，存在则表示实现分页查询接口 impl可以是js（表示JavaScript脚本）、cmd（表示SHELL脚本命令）。 2019-2010 © 版权所有 "},"jsx.html":{"url":"jsx.html","title":"5.2 使用JavaScript实现接口","keywords":"","body":"使用JavaScript实现接口 应用场景 默认情况下SQLRestful接口使用SQL来实现，但某些场景下我们不需要使用SQL而是需要调用其他Restful微服务接口： 多个Restful微服务接口的数据组合； 需要对已有的Restful数据做脱敏等实现； 第三方公有云服务接口的封装等； 配置方法 在接口定义上使用impl = \"js\"配置后可直接对exec或total实现采用JavaScript，如下所示： impl = \"js\" total = 此处的JavaScript可以使用《SQLRestful的JS脚本能力》章节中说明的内置函数。 2019-2010 © 版权所有 "},"cmd.html":{"url":"cmd.html","title":"5.3 使用外部SHELL命令实现接口","keywords":"","body":"使用外部SHELL命令实现接口 应用场景 某些情况下可能需要使用已有SHELL脚本或已实现的命令行程序来快速对外提供Restful微服务接口： 想要快速把命令行操作转成Restful微服务接口（自动化运维应用） 配置方法 在接口定义上使用impl = \"cmd\"配置后可直接对exec实现调用SHELL命令，如下所示： path = \"/docker_pull\" bind { pull = \"$input.img\" } impl = \"cmd\" exec = \"docker\" 参数绑定规则： 在bind中配置的SHELL命令输入参数会以如下方式传入到exec配置的命令中： docker pull 命令执行展开规则： ... 命令执行返回 客户端请求命令实现的微服务接口时阻塞直至命令执行完成，SQLRestful获取SHELL命令的控制台输出字符串返回。 返回数据格式参见《Restful接口返回的数据格式》章节。 2019-2010 © 版权所有 "},"jwt.html":{"url":"jwt.html","title":"5.4 使用JWT身份令牌请求其他接口","keywords":"","body":"使用JWT身份令牌请求其他接口 应用场景 如果您的SQLRestful实现需要通过应用网关调用其他微服务接口时，必然需要使用JWT规范的 身份令牌来完成调用。 准备JWT应用身份资料 通过应用网关调用其他微服务接口约定，生成JWT请求令牌必须遵循JWT RS256算法约定，需要准备证明应用身份的资料： RSA私钥：对应公钥在已在网关端登记注册 JWT安全令牌：协商密钥，由网关随机生成 以JWT应用身份运行容器 准备JWT应用身份资料后，我们需要把RSA私钥文件加载到镜像的文件系统中，然后在运行命令行中加入jwt-keyfile、jwt-secret、jwt-expires参数，如下示例命令： docker run -ti --rm \\ -v /path/of/app.pem:/sqlrestful/app.pem:ro \\ snz1/sqlrestful \\ -jwt-keyfile \"/sqlrestful/app.pem\" \\ -jwt-secret \"***********\" \\ -jwt-expires=3600 \\ ... 使用JWT请求令牌请求接口 通过上述配置后在JavaScript脚本中我们便可以使用内置的call_api函数携带令牌请求其他微服务接口： (function(){ var ratdata = call_api(\"http://appgateway.domain/paht/of/api\", { method: \"GET\", ... }) })() 默认情况下call_api根据JWT身份资料自动生成JWT请求令牌。 2019-2010 © 版权所有 "},"xeai.html":{"url":"xeai.html","title":"5.4 使用用户统一安全认证服务","keywords":"","body":"使用用户统一安全认证服务 应用场景 如果我们的接口面向用户前端，此时必然涉及用户身份验证及权限验证问题，虽然通过authorizer配置项可以使用JavaScript脚本来实现用户身份验证及权限验证，但总的来说实现还是稍显繁琐了。 此时我们可以通过security配置项来对接口定义用户及权限角色访问控制。 注：security配置项需要用户统一安全认证服务组件支持。 配置方法 security可以针对接口配置以下验证方式： 可以访问接口的登录用户或角色 不能访问接口的登录用户或角色 security { //是否允许匿名访问，为true时不判定用户身份 anonymous = false //用户所属组织域：参见 scope = \"employee\" //判定角色列表 roles = [ \"ADMIN\" ] //判定用户列表 users = [ \"neeker\" ] //角色或用户判定策略： // 为include时表示请求用户必须包含roles中定义的角色、用户必须在users定义的列表中 // 为exclude时表示请求用户不能是roles定义的角色、用户不能再users定义的列表中 //条件不满足则返回403应答 policy = \"allow\" } 运行配置 开启security配置功能需要在启动命令行中加入uumapi、useridtype、userscope参数： uumapi表示用户统一安全认证服务地址 useridtype表示通过请求头获取到的用户身份标识类型（包括：id、uname等） userscope表示登录用户所在的组织域代码（登录的用户必须在该组织域下才能访问） 使用用户统一安全认证服务的启动命令如下所示： 2019-2010 © 版权所有 "},"custom.html":{"url":"custom.html","title":"5.5 以容器(docker)方式部署服务","keywords":"","body":"如何实现自定义镜像 既然是云原生开发方式，最终我们编写的微服务接口需要以容器的方式打包部署。 准备Dockerfile文件 根据实际情况准备Dockerfile，添加开发好的SQLRestful文件（hcl）到打包镜像中，具体如下所示： # 引入sqlrestful镜像 FROM snz1/sqlrestful # 把你的HCL配置文件添加到镜像的`/sqlrestful`目录下 ADD /sqlrestful/ # 把RSA私钥文件添加到镜像的`/sqlrestful`目录下 ADD /sqlrestful/ # 根据生产环境，自定义入口配置参数 ENTRYPOINT [\"sqlrestful\", \"-driver\", \"postgres\", \"-dsn\", ..., \"-jwt-secret\", \"...\"] 2019-2010 © 版权所有 "},"db.html":{"url":"db.html","title":"6、数据库支持列表","keywords":"","body":"数据库支持列表 SQLRestful使用Go的https://github.com/jmoiron/sqlx第三方库实现SQL封装，sqlx基于database/sql，因此大部分有database/sql驱动实现的数据库都可以纳入SQLRestful实现支持。 驱动名 数据库 DSN mysql MySQL usrname:password@tcp(server:port)/dbname?option1=value1&... postgres PostgresQL postgresql://username:password@server:port/dbname?option1=value1 user= password=dbname= sslmode=disable connect_timeout=3 host= sqlite3 SQLite3 /path/to/db.sqlite?option1=value1 mssql SQLServer server=localhost\\\\SQLExpress;user id=sa;database=master;app name=MyAppName server=localhost;user id=sa;database=master;app name=MyAppName odbc:server=localhost\\\\SQLExpress;user id=sa;database=master;app name=MyAppName odbc:server=localhost;user id=sa;database=master;app name=MyAppName hdb SAP HANA hdb://user:password@host:port clickhouse Yandex ClickHouse tcp://host1:9000?username=user&password=qwerty&database=clicks&read_timeout=10&write_timeout=20&alt_hosts=host2:9000,host3:9000 oci8 Oracle username/password@host:port/sid 目前oci8驱动基于Oracle Instant Client 12.2.0.1.0编译，因此需要oci-12.2.0.1.0动态库支持。 2019-2010 © 版权所有 "}}